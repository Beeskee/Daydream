I want to understand Lisp-like languages well.  It is possible to successfully use a construct without understanding every aspect of it.  It is impossible to successfully implement a construct without understanding every aspect of it, though misunderstanding is possible.  It is easier to find creative uses for a construct when you understand it well.

I want to have a Lisp-like language that includes all the ideas I consider good and excludes all the ideas I consider bad.  Good ideas are scattered across existing Lisp-like languages.  For example, Common Lisp has a condition system but does not have delimited continuations while Racket has delimited continuations but does not have a condition system.  Excluding bad ideas makes the programming language easier to understand, implement, and use.  For example, having both dynamic and lexical scope raises questions about which free variable with the same name will be used when one is accessible dynamically and the other is accessible lexically.
