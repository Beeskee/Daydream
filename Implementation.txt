All entry points from AutoHotkey must be wrapped in "Critical" sections.  Otherwise multiple "threads" running at once can corrupt the state of the interpreter.

The mapping between imported names and their source must be retained, so their values get updated when their source is reloaded.

Think about the implications of allowing built-ins to be redefined, sandboxing, and simply displaying macro expansions, on lexical lookup.  The environment with built-ins should be chained after the outermost user-defined environment to allow redefinition.  It must also be checked after imported definitions, in case imported definitions were used to redefine them.  Since it is a defect to redefine an imported definition, whether the outermost user-defined environment or imported definitions are checked first is not relevant for correctness, but the outermost user-defined environment be checked first for efficiency.  For sandboxing to work properly we must not remove definitions for foreign function calls from the built-ins environment, because we might want to allow importing a library that uses those but does not export them.  Instead they should be defined to signal a defect condition in an environment preceding the built-ins environment in the sandboxed environment chain.  Doing it this way assures that simply displaying macro expansions can work, because there is a single shared built-ins environment that cannot be changed.  It also implies it will never be safe to return environments based on their contents, since that could be used to escape the sandbox.

The parse tree will have to be garbage collected.  It may appear that reference cycles cannot exist in it, but that is no longer true when data structure literals can describe reference cycles.

The garbage collector should close and free files that are no longer referenced.  In most programming languages, depending on this is considered bad taste.  The issue is garbage collectors often put off freeing objects for a long time, and file handles are finite on some operating systems.  Ours does not do that, so it should be okay.  It seems opening a file can fail for a variety of reasons (e.g. it does not exist, it is locked, it is read only and you tried to open it for writing, etc.) but it seems to be impossible to fail closing it, and closing one file handle does not seem to effect the others.  Actually, AutoHotkey will do this for us when we remove the last reference.

GUI elements require special handling, because they can maintain references that are invisible to our programming language.  So far the best idea I have is to have a surrogate object that is associated with a window, that you use as a handle to work with elements inside the window, which keeps a reference to all event handlers.  That would keep the garbage collector from collecting event handlers that were still in use.  The surrogate object must be freed when the window is closed.  These surrogate objects need to be garbage collector roots.  Java's Swing seems to work the same way.

Most unreadable things should be shown ('printed') between "#<" and ">", but there is no apparent convention for some things.  It would be preferable if symbols that were inserted by macros were shown in a helpful way, because they are not looked up in the caller's scope, unlike most symbols.  Maybe "#<symbol name macro>", where name is the name of the symbol, and macro is the name of the macro that generated it, would be best.  To keep the noise down, it might be best to display symbols normally if they would have the same value if looked up in the caller's scope, due to being from the same environment, so the value is /always/ the same.  This will be true of most symbols.

Most implementations of Scheme (which has hygienic macros) do store a pointer with a bound symbol to the environment it is bound in.  That is the key to avoiding accidental capture /and/ avoiding defects due to function and macro calls the macro inserts being looked up in an environment where they may be different, or not exist.

Quote, quasiquote, unquote, and unquote splicing should behave as they do in Common Lisp.  Use "Quasiquotation in Lisp" by Alan Bawden as a guide.  Specifically, "''foo" should be equivalent to "(quote (quote foo))" and quasiquotation should proceed from innermost outward, and only things with matching numbers of unquotes should be evaluated (but if more than one, the outer quotes remain on further evaluation).

So a function call (which might or might not have been inserted by a macro) looks like:
1. read the environment field of the symbol for the function name
2. read the value indexed by that symbol in that environment, which should give you an environment for the free variables of the function and the code associated with it (i.e. a closure)
3. create an environment frame containing the arguments, and chain it to the function's free variables
4. run the code with that environment; if a variable is not found in it (because it was not an argument or defined in it), look it up in the free variable chain
To be very clear, looking up the value of a symbol is a two step process, not a one step one.  You must look up the environment associated with a symbol, then look the symbol up by name.  Looking the symbol up by name directly in the caller's environment chain would cause symbols inserted by macros to be associated with the value in caller's environment chain, not the environment chain they were defined in.  When a symbol is /not/ inserted by a macro (i.e. the majority of the time) its environment will be the same as the function.

Tail call elimination is surprisingly simple.  The constructs of structured programming (other than function calls) break down to sequence, branch, and iteration.  In functional programming you can eliminate iteration by replacing it with recursion.  So we only need to handle sequence and branch.  Function calls do not complicate this, since they are effectively sequences.  If you are at the end of a sequence, or in a branch, you can replace the 'outer' return value with your current return value.  Consider how this works with nested "if".  The outer "if" needs the result of the inner "if" for its return value, but it cannot do anything with it except return it itself, so you may as well clobber its return value.  Being at the end of a sequence (like a function) while at the end of an outer sequence (again, like a function) is the same way.  So in these situations you just loop back to the start of your evaluation function instead of recursing, or faking recursion if you are using a programming language with a fixed size stack.

Be sure tail call elimination does not mess up dynamic-wind and similar things.

Stack traces should look like a stack of plates.  This wastes less horizontal space, and requires less scrolling, than a tree depiction, or showing the newest call stack frame at the bottom.

Source lines should start at 1 and columns should start at 0.  This, along with limiting columns to 80, is a convention that started with punched cards and has stuck, rather than something that makes sense from a programming point of view.  We should adopt it because editors have adopted it, and that's what the programmer will use to correct an error.

Common Lisp makes restarts unnecessarily complicated.  Restarts should be defined within the function they handle errors from, so they can access its lexical scope (and thus have better information to handle the error, and correct it using mutation).  They need to be able to receive arguments from the condition handler in case extra information needs to be provided.  Other than being looked up within the function that signaled a condition, they are handled like a normal function invocation.  No association between the condition name and the restart name is implied.  You could use one of several different restarts to handle the same condition.  The name should simply be descriptive.  The docstring can provide a more detailed description.  The condition handler should be able to read their return value, in case it wants to do anything extra (like log something) with that information.  If the condition handler returns normally, as opposed to signaling another condition, execution continues as if the evaluated form had not signaled a condition (i.e. after it).  The condition handler's return value is treated like other control flow sequences, but should usually be the value returned by the restart if one was used, or the condition handler's body if the call stack was unwound to that point.

There is one way I know of to cause trouble for our way of handling conditions.  If you construct source code as a list at run time, then run "eval" on it, it will not have passed through "read", and thus will not have the extra information the condition system needs.  The fix is to detect that this information is missing (it should be missing on the first node), and do not attempt to use it.  If a condition occurs, the location reported should be that of the "eval" that did pass through "read".  A system using syntax objects could do no better.  Racket just reports the function or macro that misbehaved, and the value at fault, at the REPL, and fails to run at all in a file.
